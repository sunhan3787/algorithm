布隆过滤器：
应用：上亿字符串查重；
一、概念：布隆过滤器是一种比较巧妙的概率型数据结构，得到某字符串，一定不存在或者可能存在的结果。

二、应用场景：
1.上亿字符串查重;
2.使用word文档时，判断某个单词是否拼写正确；
3.网络爬虫程序，不去爬相同的url页面，用布隆过滤器去重；
4.垃圾邮件过滤算法的设计；
5.(redis)缓存崩溃后造成的缓存击穿的解决方案；
所谓的缓存穿透就是服务调用方每次都是查询不在缓存中的数据，这样每次服务调用都会到数据库中进行查询，如果这类请求比较多的话，就会导致数据库压
力增大，这样缓存就失去了意义。利用布隆过滤器我们可以预先把数据查询的主键，比如用户 ID 或文章 ID 缓存到过滤器中。当根据 ID 进行数据查询的时
候，我们先判断该 ID 是否存在，若存在的话，则进行下一步处理。若不存在的话，直接返回，这样就不会触发后续的数据库查询。需要注意的是缓存穿透不
能完全解决，我们只能将其控制在一个可以容忍的范围内。
6.FBI，一个嫌疑人的名字是否已经在嫌疑名单上；
...
三、优缺点：
STL Map:底层是rbtree;占用内存和hashmap差不多
Hashmap: unordered_map
缺点：1.散列表，最大10000个bit, (像url比较耗内存)当存储元素超过表的一半，需要考虑扩容的问题，
2.占空间大，以空间换时间的算法
3.哈希冲突，严重会是hashmap退化成链表的性能
Bloomfilter:布隆过滤器特点是：1.不会去存储字符串（节省内存空间）；2.高效地插入和查询性能。相比于传统的 List、Set、Map 等数据结构，它更高效、
占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的；具有一定的误差识别率和不可删除。
不可删除的原因：
在布隆过滤器算法中，添加一个元素后，如果设置了k个bit为1，且某个bit位碰撞后，我们删除该元素时恰恰设置该bit位为0，则碰撞的元素无法判断，因此
不能在布隆过滤器中删除元素。

四、布隆过滤器的数据结构：bit向量数组在堆内存中申请；
1.向量表的长度对hash冲突影响是很大的，数组越长冲突越低，越占内存；
2.布隆过滤器用k>=1个hash函数去做映射；
3.用多个hash是为了解决避免冲突的问题；

（1）向量表长度，可以设置
（2）用多少个hash函数
（3）期望误差（冲突），所设置的误差值直接决定khash函数的个数；
（4）最多放多少个元素；

五、布隆过滤器工作原理
检查一个key是否不存在或者有可能存在,根据元素key个数n,和期望误差p，1.计算出内存大小m[即向量表的长度]，2.计算出hash函数的个数K；
k个Hash函数返回字符串的k个hash值hash_num对应向量表的下标索引，则对应下标bit[hash_num]处会置1。检索时，如果这些点有任何一个0，则被检元素
一定不在；如果都是1，则被检元素很可能存在。因此布隆过滤器缺点是其返回的结果是可能存在或者不存在。

误差计算：
假设布隆过滤器中的hash函数满足简单一致散列，每个元素都等概率地hash到m个slot中的任何一个，其中m是向量表长度即bit数；对某一bit位在一个元素
经过hash函数
返回的hash_num没有被置1的概率是p = (1-(1/m));
那么k个hash_num对应的p = (1-(1/m))^k ;
插入了n个元素p = (1-(1/m))^kn ；
查询过程中，如果待查询元素对应的k个 bits全部置位为1，判定其在集合中。则误判概率是p =(1- (1-(1/m))^kn)^k ；
经过数学推导最终可得到：p = 2-ln2(m/n) ; 得到占内存大小 m = bits;
根据m和n 的值计算出hash函数的个数k = (ln2 * m)/n;   [ln2大约是0.7]

六、性能测试：
    为每个URL分配两个字节就可以达到千分之几的冲突。比较保守的实现是，为每个URL分配4个字节，项目和位数比是1∶32，误判率是0.00000021167340。
对于5000万数量级的URL，布隆过滤器只占用200MB的空间。
